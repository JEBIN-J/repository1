from django.shortcuts import render, redirect
from .models import ChatMessage
import json
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync # For sending messages from sync view
from django.utils.dateformat import DateFormat
from django.utils.timezone import localtime


def chat_view(request):
    if request.method == 'POST':
        user = request.POST.get('user')
        message_text = request.POST.get('message')

        if user and message_text:
            channel_layer = get_channel_layer()

            # Create and save the message to get timestamp and ID (optional, if needed immediately)
            # Or, let consumer handle saving. For this task, consumer saves.
            # We still need a representation of the message to send.
            # Let's simulate what the consumer would create for consistency,
            # although the consumer will be the one creating the actual DB record.

            # Send message to channel layer group
            # The consumer will save the message and then broadcast it.
            async_to_sync(channel_layer.group_send)(
                'chat_room', # Must match the group name in consumer
                {
                    'type': 'chat_message', # This will call the chat_message method in consumer
                    'message': message_text,
                    'user': user,
                    # Timestamp will be generated by the consumer upon saving
                }
            )
            return redirect('chat_view') # Redirect to clear POST and prevent resubmission

    messages = ChatMessage.objects.all().order_by('timestamp')
    return render(request, 'chat/chat.html', {'messages': messages})
